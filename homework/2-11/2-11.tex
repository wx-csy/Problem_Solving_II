\documentclass[a4paper,11pt]{article}
\usepackage{ctex}
\usepackage{enumerate}
\usepackage{times}
\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{clrscode3e}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\allowdisplaybreaks[4]
\renewcommand{\labelenumi}{\textbf{\emph{\alph{enumi}}.}}
\begin{document}
  \title{论题~2-11~作业}
  \author{姓名：陈劭源 \and 学号：161240004}
  \date{}
  \maketitle

  \section{[TC] Problem 12.1-2}
  In a binary search tree, every node is greater than or equal to all the elements in its left subtree, and is less than or equal to all the elements in its right subtree. However, in a min-heap, every node is less than or equal to its child(ren), both left and right, if exist. \par
  Min-heap property can not be used to print out the keys in sorted order in $O(n)$ time. If it can, then we sort the $n$ keys in $O(n)$ time, because building an $n$-node heap only takes a running time of $O(n)$, and this is contradictory to the $\Omega(n \log n)$ lower bound for comparison-based sorting algorithm.

  \section{[TC] Problem 12.1-5}
  Suppose, to the contrary, that there exists a comparison-based algorithm, that constructs an $n$-element binary search tree in $o(n \log n)$ time. We use this algorithm to build a binary search tree. The inorder traversal of the binary search tree gives the list of all the elements in the tree in sorted order, and it takes a running time of $O(n)$. That means, we can sort $n$ elements in $o(n \log n)$ running time, which is contradictory
  to the $\Omega(n \log n)$ lower bound for comparison-based sorting algorithm.

  \section{[TC] Problem 12.2-5}
  When a node in a binary search tree has two children, then its successor is the minimum element in its right subtree. In \proc{Tree-Minimum}, line 1, the \While loop condition ``$\attrib{x}{left} \neq \const{nil}$'' guarantees that when the loop terminates, the minimum element, $x$ must not have a left child. \par
  Likewise, the predecessor is the maximum element in its left subtree, and the \While loop condition in \proc{Tree-Maximum} guarantees that the maximum element must not have a right child.

  \section{[TC] Problem 12.2-8}
  The $k$ successive calls to \proc{Tree-Successor} output a consecutive subsequence of the inorder traversal of the tree. During this process, every node, say $x$, in the tree, is visited at most three times: entering the tree rooted in $x$ from its parent, then visiting its left subtree; leaving its left subtree, outputting $x$ itself, and then visiting its right subtree; leaving the right subtree, then returning to its parent. The $k$ elements visited and outputted takes a running time of $O(k)$. Now, we are going to consider the elements visited but not outputted. \par
  Assume, the lowest common ancestor of the outputted elements is $a$, then $a$ must be outputted according to the binary search tree property. In the left subtree of $a$, we claim that there do not exist two elements $b_1, b_2$ at the same level visited but not outputted. Otherwise, let $a'$ be their lowest common ancestor, and assume $b_1$ is in the left subtree of $a'$ and $b_2$ is in the right one. Since both $b_1$ and $b_2$ have been visited, the procedure must have left the left subtree of $a'$ and entered the right subtree of $a'$, and thus $a'$ must have been outputted. Now, we have proved that both $a$ and $a'$ have been outputted, but $b_2$, between $a$ and $a'$, is not outputted, which leads to a contradiction.
  So, there are at most $h$ elements visited but not outputted in the left subtree of $a$, and they take a running time of $O(h)$. Likewise the elements visited but not outputted in the right subtree of $a$ take a running time of $O(h)$. \par
  Therefore, the total running time is $O(k+h)$.

    \vspace{0.3cm}
  \scriptsize
  \begin{centering}
  \begin{tikzpicture}[line width = 1pt,
                    solid/.style = {circle, draw, fill = black, minimum size = 0.3cm},
                    empty/.style = {circle, draw, fill = white, minimum size = 0.3cm}]
  \node at (6.7,0) {$a$};
  \node [empty, line width = 2pt] (T01) at (6,0) {8};
  \node [empty, dashed] (T11) at (4,-1) {4};
  \node [empty, dashed] (T12) at (8,-1) {12};
  \node [empty] (T21) at (3,-2) {2};
  \node [empty, line width = 2pt] (T22) at (5,-2) {6};
  \node [empty, dashed] (T23) at (7,-2) {10};
  \node [empty] (T24) at (9,-2) {14};
  \node [empty] (T31) at (2.5,-3) {1};
  \node [empty] (T32) at (3.5,-3) {3};
  \node [empty, line width = 2pt] (T33) at (4.5,-3) {5};
  \node [empty, line width = 2pt] (T34) at (5.5,-3) {7};
  \node [empty, line width = 2pt] (T35) at (6.5,-3) {9};
  \node [empty] (T36) at (7.5,-3) {11};
  \node [empty] (T37) at (8.5,-3) {13};
  \node [empty] (T38) at (9.5,-3) {15};

  \node [empty] at (12, -1){};
  \node [right] at (12.5, -1) {Neither visited nor outputted};
  \node [empty, dashed] at (12, -2){};
  \node [right] at (12.5, -2) {Visited but not outputted};
  \node [empty, line width = 2pt] at (12, -3){};
  \node [right] at (12.5, -3) {Visited and outputted};

  \node at (6, -4) {Both in left and right subtree of $a$, there do not exist two elements visited but not outputted in the same level.};
  \draw [thin] (T01) -- (T11);
  \draw [thin] (T01) -- (T12);
  \draw [thin] (T11) -- (T21);
  \draw [thin] (T11) -- (T22);
  \draw [thin] (T12) -- (T23);
  \draw [thin] (T12) -- (T24);
  \draw [thin] (T21) -- (T31);
  \draw [thin] (T21) -- (T32);
  \draw [thin] (T22) -- (T33);
  \draw [thin] (T22) -- (T34);
  \draw [thin] (T23) -- (T35);
  \draw [thin] (T23) -- (T36);
  \draw [thin] (T24) -- (T37);
  \draw [thin] (T24) -- (T38);
  \end{tikzpicture} \par
  \end{centering}
  \normalsize

  \section{[TC] Problem 12.2-9}
  If $x$ is the left child of $y$, since $x$ is a leaf, $x$ is the rightmost node in $x$'s left subtree, so $\attrib{x}{key}$ is the largest key in $T$ smaller than $\attrib{y}{key}$, i.e. $\attrib{y}{key}$ is the smallest key in $T$ larger than $\attrib{x}{key}$. \par
  If $x$ is the right child of $y$, $x$ is the leftmost node in $x$'s right subtree because $x$ is a leaf, so $\attrib{x}{key}$ is the smallest key in $T$ larger than $\attrib{y}{key}$, i.e. $\attrib{y}{key}$ is the largest key in $T$ smaller than $\attrib{x}{key}$.

  \section{[TC] Problem 12.3-5}
  \begin{codebox}
  \Procname{$\proc{Parent}(T, x)$}
  \li $y \gets x$
  \li \While $\attrib{y}{right} \neq \const{nil}$
  \li \Do $y \gets \attrib{y}{right}$
      \End
  \li $y \gets \attrib{y}{succ}$
  \li \If $y \neq \const{nil}$ and $\attrib{y}{left} \isequal x$
      \Comment $x$ is the left child of its parent
  \li \Do \Return $y$
  \li \Else \Comment $x$ is the right child of its parent
  \li    \If $y \isequal \const{nil}$
  \li    \Do $y \gets \attrib{T}{root}$
  \li    \Else
  \li        $y \gets \attrib{y}{left}$
         \End
  \li    \While $\attrib{y}{right} \neq x$
  \li    \Do $y \gets \attrib{y}{right}$
         \End
  \li    \Return $y$
      \End
  \end{codebox}
  \begin{codebox}
  \Procname{$\proc{Tree-Search}(x, k)$}
  \li \If $x \isequal \const{nil}$ or $k \isequal \attrib{x}{key}$
  \li \Do \Return $x$
      \End
  \li \If $k < \attrib{x}{key}$
  \li \Do \Return $\proc{Tree-Search}(\attrib{x}{left}, k)$
  \li \Else
  \li     \Return $\proc{Tree-Search}(\attrib{x}{right}, k)$
  \end{codebox}
  \begin{codebox}
  \Procname{$\proc{Tree-Insert'}(T, z)$}
  \li $y \gets \const{nil}$
  \li $x \gets \attrib{T}{root}$
  \li $pred \gets \const{nil}$
  \li \While $x \neq \const{nil}$
  \li \Do $y \gets x$
  \li     \If $\attrib{z}{key} < \attrib{x}{key}$
  \li     \Do $x \gets \attrib{x}{left}$
  \li     \Else
  \li         $pred \gets x$
  \li         $x \gets \attrib{x}{right}$
          \End
      \End
  \li \If $y \isequal \const{nil}$
  \li \Do $\attrib{T}{root} \gets z$
  \li     $\attrib{z}{succ} \gets \const{nil}$ 
  \li \ElseIf $\attrib{z}{key} < \attrib{y}{key}$
  \li \Do $\attrib{y}{left} \gets z$
  \li     $\attrib{z}{succ} \gets y$ \Comment maintain the successor
  \li     $\attrib{pred}{succ} \gets z$
  \li \Else
  \li     $\attrib{y}{right} \gets z$
  \li     $\attrib{z}{succ} \gets \attrib{y}{succ}$ \Comment maintain the successor
  \li     $\attrib{y}{succ} \gets z$
      \End
  \end{codebox}
  \begin{codebox}
  \Procname{$\proc{Transplant'}(T, u, v)$}
  \li $p \gets \proc{Parent}(T, u)$
  \li \If $p \isequal \const{NIL}$
  \li \Do $\attrib{T}{root} \gets v$
  \li \ElseIf $u \isequal \attrib{p}{left} $
  \li \Do $\attrib{p}{left} \gets v$
  \li \Else 
  \li     $\attrib{p}{right} \gets v$
      \End
  \end{codebox}
  \begin{codebox}
  \Procname{$\proc{Predecessor'}(T, x)$}
  \li \If $\attrib{x}{left} \neq \const{nil}$
  \li \Do \Return $\proc{Tree-Maximum}(\attrib{x}{left})$
  \li \Else
  \li     $y \gets \attrib{T}{root}$
  \li     $pred \gets \const{nil}$
  \li \While $x \neq y$
  \li \Do \If $\attrib{x}{key} < \attrib{y}{key}$
  \li     \Do $y \gets \attrib{y}{left}$
  \li     \Else
  \li         $pred \gets y$
  \li         $y \gets \attrib{y}{right}$
          \End
      \End
  \li \Return $pred$
  \end{codebox}
  \begin{codebox}
  \Procname{$\proc{Tree-Delete'}(T, z)$}
  \li $pred \gets \proc{Predecessor'}(T, z)$
  \li \If $\attrib{z}{left} \isequal \const{nil}$
  \li \Do $\proc{Transplant}(T, z, \attrib{z}{right})$
  \li \ElseIf $\attrib{z}{right} \isequal \const{nil}$
  \li \Do $\proc{Transplant}(T, z, \attrib{z}{left})$
  \li \Else
  \li     $y \gets \proc{Tree-Minimum}(\attrib{z}{right})$
  \li     \If $\proc{Parent}(T,y) \neq z$
  \li     \Do $\proc{Transplant}(T, y, \attrib{y}{right})$
  \li         $\attrib{y}{right} \gets \attrib{z}{right}$
          \End
  \li     $\proc{Transplant}(T, z, y)$
  \li     $\attrib{y}{left} \gets \attrib{z}{left}$
      \End
  \li $\attrib{pred}{succ} \gets \attrib{z}{succ}$
  \end{codebox}
  Every procedure above runs in $O(h)$ time.
  
  \section{[TC] Problem 12-1}
  \begin{enumerate}
    \item When all the keys are identical, the binary search tree is degenerate, i.e. it becomes a linked list, so inserting $n$ items with identical keys into an initially empty binary search tree takes a running time of $O(n^2)$.
    \item The binary search tree is balanced, because this strategy ensures that, for every node, its larger subtree contains at most one more node than the other, which means, the height of an $n$-element tree is $\lceil \lg (n+1) \rceil$. Inserting an element to a balanced tree of height $h$ runs in $O(h)$ time. Therefore, inserting $n$ identical elements takes a running time of
        $$ O\left(\sum_{i=1}^{n} \lceil \lg i \rceil \right) = O(n \lg n) $$
    \item We have only to insert the node to the head of the list, which takes $O(1)$ time, and inserting $n$ items takes $O(n)$ time in total.
    \item The worst case, is that, the tree is degenerate and becomes a linked list, and inserting $n$ items with identical keys takes a running time of $O(n^2)$. \par
        To derive the expected running time, consider the leaves (external nodes) in the tree. Let $h_1, h_2, \cdots h_k$ denote the height of the leaves in an $n$-element tree. We claim that $k=n+1$ and $\sum_{i=1}^{n+1} (1/2)^{h_i} = 1$. This can be easily proved by mathematical induction: when the tree is empty, the only external node is the root, whose height is 0; for any tree with $n$ elements, a lowest internal node, assuming its height being $h$, just occupies a leaf of a tree with $n-1$ elements, but gives two new leaves of height $h+1$. \par
        The expected running time of inserting a node into an $n$-element binary search tree is $E(X) = \sum_{i=1}^{n+1} h_i(1/2)^{h_i}$. Substitution $H_i = (1/2)^{h_i}$ gives
        $$ E(X) = - \sum_{i=1}^{n+1} H_i \lg H_i \qquad \text{with} \quad \sum_{i=1}^{n+1} H_i = 1$$
        By Jensen's inequality, $E(X)$ is maximized when $H_1 = H_2 = \cdots = H_{n+1} = 1/(n+1)$, thus $E(X) \leq \lg (n+1) = O(\lg n)$. Therefore, the expected running time of inserting $n$ elements is $O(n \lg n)$.

        \vspace{0.3cm}
        \scriptsize
        \begin{centering}
        \begin{tikzpicture}[line width = 1pt,
                        solid/.style = {circle, draw, fill = black, minimum size = 0.3cm},
                        empty/.style = {circle, draw, fill = white, minimum size = 0.3cm}]
        \node [empty] (T01) at (6,0) {a};
        \node [empty] (T11) at (4,-1) {b};
        \node [empty] (T12) at (8,-1) {c};
        \node [empty] (T21) at (3,-2) {d};
        \node [solid] (T22) at (5,-2) {};    \node [align=center] at (5,-2.7) {$h_1=2$ \\ $\left(\frac{1}{2}\right)^{h_1} = \frac{1}{4}$};
        \node [empty] (T23) at (7,-2) {e};
        \node [solid] (T24) at (9,-2) {};    \node [align=center] at (9,-2.7) {$h_2=2$ \\ $\left(\frac{1}{2}\right)^{h_2} = \frac{1}{4}$};
        \node [solid] (T31) at (2.5,-3) {};  \node [align=center] at (2.3,-3.7) {$h_3=3$ \\ $\left(\frac{1}{2}\right)^{h_3} = \frac{1}{8}$};
        \node [solid] (T32) at (3.5,-3) {};  \node [align=center] at (3.7,-3.7) {$h_4=3$ \\ $\left(\frac{1}{2}\right)^{h_4} = \frac{1}{8}$};
        \node [solid] (T33) at (6.5,-3) {};  \node [align=center] at (6.3,-3.7) {$h_5=3$ \\ $\left(\frac{1}{2}\right)^{h_5} = \frac{1}{8}$};
        \node [solid] (T34) at (7.5,-3) {};  \node [align=center] at (7.7,-3.7) {$h_6=3$ \\ $\left(\frac{1}{2}\right)^{h_6} = \frac{1}{8}$};

        \node [solid] at (12, -1){};
        \node [right] at (12.3, -1) {Leaf};

        \draw [thin] (T01) -- (T11);
        \draw [thin] (T01) -- (T12);
        \draw [thin] (T11) -- (T21);
        \draw [thin] (T11) -- (T22);
        \draw [thin] (T12) -- (T23);
        \draw [thin] (T12) -- (T24);
        \draw [thin] (T21) -- (T31);
        \draw [thin] (T21) -- (T32);
        \draw [thin] (T23) -- (T33);
        \draw [thin] (T23) -- (T34);
        \end{tikzpicture} \par
        \end{centering}
        \normalsize
  \end{enumerate}
  \section{[TC] Problem 13.1-5}
  The shortest simple path and the longest simple path contain the same number of black nodes, and the shortest possible path contains only black nodes, and the longest possible path contains alternately arranged red and black nodes. Since the leaf must be black, the longest simple path is at most twice as long as the shortest simple path.

  \section{[TC] Problem 13.1-6}
  The smallest possible number is $2^k - 1$, which occurs when all the nodes are black. \par
  The largest possible number is $4^k - 1$, which occurs when the red and black nodes are alternately arranged in every path.

  \section{[TC] Problem 13.1-7}
  （不会）

  \section{[TC] Problem 13.2-2}
  If a node has a right child which is not \attrib{T}{nil}, we can perform a left rotation on it; if it has a left child which is not \attrib{T}{nil}, we can perform a right rotation on it. So the number of possible rotations is the number of the children which is not \attrib{T}{nil}. Note that every node in a binary search tree is a child of other node, except the root, so there are $n-1$ children which is not \attrib{T}{nil}, thus there are exactly $n-1$ possible rotations in every $n$-node rotation binary search tree.

  \section{[TC] Problem 13.3-1}
  If we set $z$'s color to black, though property 4 would not be violated, property 5 will be violated, because the path to $z$ would have one more black nodes than other paths.

  \section{[TC] Problem 13.3-5}
  If a red-black tree has no red node, it must be a tree with every level completely filled, otherwise, property 5 is violated. Suppose, to the contrary that inserting $n$ nodes with \proc{RB-Insert} can form such a tree. Consider the last element $z$ inserted to the tree. $z$'s parent must be black before insertion, otherwise, the other child of $z$'s parent must be black, and the property 5 is violated. Therefore, property 2 and property 4 will not be violated after insertion, the procedure \proc{RB-Insert-Fixup} does nothing and $z$ remains red, which leads to contradiction.

  \section{[TC] Problem 13.4-1}
  In case 1, $x$'s sibling is red, the procedure switches the colors of $x$'s sibling and $x$'s parent, and then performs a left rotation on $x$'s parent, after which the parent node is black. \par
  In case 2, the procedure only changes the color of $x$'s sibling, which will not affect the color of the root. \par
  In case 3, the procedure switches the colors of $w$ and $w$'s left child, then performs a right rotation, after which the parent node is black. \par
  In case 4, $x$ is assigned the root of the tree, which causes the \While loop to terminate, and then the color of $x$ is set black. \par
  Therefore, after executing \proc{RB-Delete-Fixup}, the root of the tree must be black.

  \section{[TC] Problem 13.4-2}
  When both $x$ and $\attrib{x}{p}$ are red, the \While loop in \proc{RB-Delete-Fixup} will not be executed, and the color of $x$ is set black, thus property 4 is restored.

  \section{[TC] Problem 13.4-7}
  The resulting red-black tree might be changed. Here's an example. \par
\begin{quote}
  Before insertion: \par
    \vspace{0.3cm}
    \scriptsize
    \begin{centering}
    \begin{tikzpicture}[line width = 1pt,
                    solid/.style = {circle, draw, fill = black, minimum size = 0.3cm},
                    empty/.style = {circle, draw, fill = white, minimum size = 0.3cm}]
    \node [white, solid] (T01) at (2,0) {\textbf{3}};
    \node [empty] (T11) at (1,-1) {2};
    \draw [thin] (T01) -- (T11);
    \end{tikzpicture} \par
    \end{centering}
    \normalsize
  Inserting $1$ to the red-black tree: \par
    \vspace{0.3cm}
    \scriptsize
    \begin{centering}
    \begin{tikzpicture}[line width = 1pt,
                    solid/.style = {circle, draw, fill = black, minimum size = 0.3cm},
                    empty/.style = {circle, draw, fill = white, minimum size = 0.3cm}]
    \node [white, solid] (S01) at (-2,-0.5) {\textbf{3}};
    \node [empty] (S11) at (-3,-1.5) {2};
    \draw [thin] (S01) -- (S11);
    \draw [->] (-1.3,-1) -- (0.2,-1);
    \node [white, solid] (T01) at (3,0) {\textbf{3}};
    \node [empty] (T11) at (2,-1) {2};
    \node [empty] (T12) at (1,-2) {1};
    \draw [thin] (T01) -- (T11) -- (T12);
    \draw [->] (3.7,-1) -- (5.2,-1);
    \node [right] at (2, -2.6) {$\proc{RB-Delete-Fixup}$, case 3 occurs:};
    \node [right] at (2, -3.0) {Change the colors of nodes 2 and 3, then right rotate.};
    \node [white, solid] (U01) at (7, -0.5) {\textbf{2}};
    \node [empty] (U11) at (6,-1.5) {1};
    \node [empty] (U12) at (8,-1.5) {3};
    \draw [thin] (U01) -- (U11);
    \draw [thin] (U01) -- (U12);
    \end{tikzpicture} \par
    \end{centering}
    \normalsize
  Deleting $1$ from the red-black tree: \par
    \vspace{0.3cm}
    \scriptsize
    \begin{centering}
    \begin{tikzpicture}[line width = 1pt,
                    solid/.style = {circle, draw, fill = black, minimum size = 0.3cm},
                    empty/.style = {circle, draw, fill = white, minimum size = 0.3cm}]
    \node [white, solid] (T01) at (2, -0.5) {\textbf{2}};
    \node [empty] (T11) at (1,-1.5) {1};
    \node [empty] (T12) at (3,-1.5) {3};
    \draw [thin] (T01) -- (T11);
    \draw [thin] (T01) -- (T12);
    \draw [->] (3.7,-1) -- (5.2,-1);
    \node [white, solid] (U01) at (6, -0.5) {\textbf{2}};
    \node [empty] (U12) at (7,-1.5) {3};
    \draw [thin] (U01) -- (U12);
    \end{tikzpicture} \par
    \end{centering}
    \normalsize
\end{quote}
\end{document}
